import math
import os

import colour
import numpy as np
import matplotlib.patches as patches
import matplotlib.pyplot as plt

sRGBMatrix = np.array([
    [3.2406, -1.5372, -0.4986],
    [-0.9689, 1.8758, 0.0415],
    [0.0557, -0.2040, 1.0570],
])


def PlanckEquation(x):
    C = 2.99792458e8
    H = 6.6260755e-34
    K = 1.380658e-23
    T = 6504

    x /= 1e9
    t = 2 * C * C * H
    t /= math.pow(x, 5)
    t /= (math.pow(math.e, (H * C) / (K * T * x)) - 1.)
    return t


D65_590 = PlanckEquation(590)


def norm_D65(x):
    return PlanckEquation(x) / D65_590


def load_CIEXYZ():
    CIEXYZ = {}
    with open("CIEXYZ") as f:
        for line in f.readlines():
            wavelength, x, y, z = line.split()
            CIEXYZ[int(wavelength)] = np.array([float(x), float(y), float(z)])
    return CIEXYZ


def get_CIEXYZ(CIEXYZ, wavelength):
    lb = CIEXYZ[math.floor(wavelength)]
    ub = CIEXYZ[math.ceil(wavelength)]
    return (lb + ub) * (wavelength - lb)


def calc_XYZ(spd, CIEXYZ):
    XYZ = np.zeros(3)
    N = 0.0
    for wavelength, value in spd:
        XYZ += value * norm_D65(wavelength) * get_CIEXYZ(CIEXYZ, wavelength)
        N += norm_D65(wavelength) * get_CIEXYZ(CIEXYZ, wavelength)[1]
    return XYZ / N


def XYZ2sRGB(XYZ):
    def _f(x):
        if x < 0.0031308:
            return x * 12.92
        else:
            return 1.055 * math.pow(x, 1.0 / 2.4) - 0.055

    sRGB = sRGBMatrix @ XYZ
    sRGB = np.array([_f(sRGB[0]), _f(sRGB[1]), _f(sRGB[2])])
    sRGB = np.clip(sRGB, 0., 1.)
    return sRGB


def prepare_colour():
    cmfs = colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[
        'CIE 1931 2 Degree Standard Observer']
    #illuminant = colour.SpectralPowerDistribution(
    #    {i: PlanckEquation(i) / PlanckEquation(560)
    #     for i in range(300, 780)})
    illuminant = colour.SDS_ILLUMINANTS['D65']
    return cmfs, illuminant


def calc_XYZ_by_colour(spd, cmfs, illuminant):
    spd = {k: v for k, v in spd}
    spd = colour.SpectralDistribution(spd)
    spd.interpolate(colour.SpectralShape(400, 700, 1))
    return colour.sd_to_XYZ(spd, cmfs, illuminant) / 100.


def XYZ2sRGB_by_colour(XYZ):
    sRGB = colour.XYZ_to_sRGB(XYZ)
    sRGB = np.clip(sRGB, 0., 1.)
    return sRGB


def read_pigment(file):
    spd = []
    with open(file) as f:
        for line in f.readlines()[2:]:
            wavelength, value = line.split()
            spd.append([float(wavelength), float(value)])
    return spd


def plot(h, w, i, name, XYZ, sRGB, author):
    ax = plt.subplot(h, w, i)
    ax.set_axis_off()
    ax.text(0,
            0,
            f"{name} generated by {author}\nXYZ: {XYZ}\nsRGB{sRGB}",
            fontsize='x-small')
    ax.add_patch(patches.Rectangle((0, 0), 10, 10, color=sRGB))


def main():
    CIEXYZ = load_CIEXYZ()
    cmfs, illuminant = prepare_colour()

    pigments = sorted([x for x in os.listdir(".") if x.endswith("plot")])
    n = len(pigments)
    w = 2
    h = math.ceil(n / w)
    for i, x in enumerate(pigments):
        print(("=" * 10) + x + ("=" * 10))
        spd = read_pigment(x)

        XYZ = calc_XYZ(spd, CIEXYZ)
        print("XYZ:", XYZ)
        sRGB = XYZ2sRGB(XYZ)
        print("sRGB:", sRGB)
        plot(h, w * 2, (i + 1) * 2 - 1, x, XYZ, sRGB, "me")

        XYZ = calc_XYZ_by_colour(spd, cmfs, illuminant)
        print("XYZ:", XYZ)
        sRGB = XYZ2sRGB_by_colour(XYZ)
        print("sRGB:", sRGB)
        plot(h, w * 2, (i + 1) * 2, x, XYZ, sRGB, "colour")

    plt.show()

    sd = colour.SpectralDistribution(
        {k: norm_D65(k) * v[1]
         for k, v in CIEXYZ.items()})
    colour.plotting.plot_single_sd(sd)


if __name__ == "__main__":
    main()
